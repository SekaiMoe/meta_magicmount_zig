import { exec } from 'kernelsu';
import { MockAPI } from './mock.js';

export const DEFAULT_CONFIG = {
  moduledir: '/data/adb/modules',
  tempdir: '',
  mountsource: 'KSU',
  logfile: '/data/adb/magic_mount/mm.log',
  verbose: false,
  umount: true,
  partitions: []
};

const CONFIG_PATH = '/data/adb/magic_mount/mm.conf';

function isTrueValue(v) {
  const s = String(v).trim().toLowerCase();
  return ['1', 'true', 'yes', 'on'].includes(s);
}

export async function loadConfig() {
  if (import.meta.env.DEV) {
    return MockAPI.loadConfig(DEFAULT_CONFIG);
  }

  const { errno, stdout } = await exec(
    `[ -f "${CONFIG_PATH}" ] && cat "${CONFIG_PATH}" || echo ""`
  );

  if (errno !== 0) throw new Error("Read config failed");
  if (!stdout.trim()) return { ...DEFAULT_CONFIG };

  const result = { ...DEFAULT_CONFIG };
  const lines = stdout.split('\n');
  for (let line of lines) {
    line = line.trim();
    if (!line || line.startsWith('#')) continue;
    const [key, ...vals] = line.split('=');
    if (!key || !vals.length) continue;
    const value = vals.join('=').trim();

    switch (key.trim()) {
      case 'module_dir': result.moduledir = value; break;
      case 'temp_dir': result.tempdir = value; break;
      case 'mount_source': result.mountsource = value; break;
      case 'log_file': result.logfile = value; break;
      case 'debug': result.verbose = isTrueValue(value); break;
      case 'umount': result.umount = isTrueValue(value); break;
      case 'partitions': 
        result.partitions = value.split(',').map(s => s.trim()).filter(Boolean); 
        break;
    }
  }
  return result;
}

export async function saveConfig(cfg) {
  if (import.meta.env.DEV) {
    return MockAPI.saveConfig(cfg);
  }

  const lines = ['# Magic Mount Configuration File', '# Generated by Web UI', ''];
  lines.push(`module_dir=${cfg.moduledir || DEFAULT_CONFIG.moduledir}`);
  if (cfg.tempdir) lines.push(`temp_dir=${cfg.tempdir}`);
  lines.push(`mount_source=${cfg.mountsource || DEFAULT_CONFIG.mountsource}`);
  if (cfg.logfile) lines.push(`log_file=${cfg.logfile}`);
  lines.push(`debug=${cfg.verbose ? 'true' : 'false'}`);
  lines.push(`umount=${cfg.umount ? 'true' : 'false'}`);
  if (cfg.partitions.length > 0) lines.push(`partitions=${cfg.partitions.join(',')}`);

  const content = lines.join('\n').replace(/'/g, "'\\''");
  const shell = `mkdir -p "$(dirname "${CONFIG_PATH}")" && printf '%s\n' '${content}' > "${CONFIG_PATH}"`;
  
  const { errno, stderr } = await exec(shell);
  if (errno !== 0) throw new Error(stderr || "Save failed");
  return true;
}

export async function fetchLog(path, isOld = false) {
  if (import.meta.env.DEV) {
    return MockAPI.fetchLog(path, isOld);
  }

  const fullPath = isOld ? `${path}.old` : path;
  const { errno, stdout, stderr } = await exec(
    `[ -f "${fullPath}" ] && cat "${fullPath}" || echo ""`
  );
  if (errno !== 0) throw new Error(stderr);
  return stdout || '';
}

export async function fetchModules(moduleDir) {
  if (import.meta.env.DEV) {
    const mocks = await MockAPI.fetchModules(moduleDir);
    return mocks.map(m => ({ ...m, toggling: false }));
  }

  const shell = `
    MOD_DIR="${moduleDir}"
    [ -d "$MOD_DIR" ] || exit 0
    for m in "$MOD_DIR"/*; do
      [ -d "$m" ] || continue
      [ -d "$m/system" ] || continue
      name="$(basename "$m")"
      disabled=0; skip=0
      [ -e "$m/disable" ] || [ -e "$m/remove" ] && disabled=1
      [ -e "$m/skip_mount" ] && skip=1
      printf '%s|%s|%s\n' "$name" "$disabled" "$skip"
    done
  `;
  
  const { errno, stdout } = await exec(shell);
  if (errno !== 0) throw new Error("List modules failed");

  return stdout.split('\n')
    .map(l => l.trim())
    .filter(Boolean)
    .map(line => {
      const [name, dis, skip] = line.split('|');
      return {
        name,
        disabledByFlag: dis === '1',
        skipMount: skip === '1',
        toggling: false
      };
    });
}

export async function toggleModuleSkip(moduleDir, modName, shouldSkip) {
  if (import.meta.env.DEV) {
    return MockAPI.toggleModuleSkip(moduleDir, modName, shouldSkip);
  }

  const path = `${moduleDir}/${modName}/skip_mount`;
  const cmd = shouldSkip ? `touch "${path}"` : `rm -f "${path}"`;
  const { errno, stderr } = await exec(cmd);
  if (errno !== 0) throw new Error(stderr);
}
